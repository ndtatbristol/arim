
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>arim.model &#8212; arim 0.10.0.rc1 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../_static/documentation_options.js?v=5a92b29a"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/arim/model';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">arim 0.10.0.rc1 documentation</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../installation/index.html">
    Installation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../user/index.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api.html">
    API Reference
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../installation/index.html">
    Installation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../user/index.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api.html">
    API Reference
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">arim.model</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for arim.model</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Core functions of the forward models.</span>

<span class="sd">.. seealso::</span>
<span class="sd">    :mod:`arim.models`</span>
<span class="sd">    :mod:`arim.scat`</span>
<span class="sd">    :mod:`arim.ut`</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># This module is imported on demand. It should be imported only for modelling.</span>
<span class="c1"># Function that are not modelling-specific should go to arim.ut, which is always imported.</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">abc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">namedtuple</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numba</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.core.umath</span><span class="w"> </span><span class="kn">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">_scat</span><span class="p">,</span> <span class="n">helpers</span><span class="p">,</span> <span class="n">signal</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">core</span> <span class="k">as</span> <span class="n">c</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">use_parallel</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ARIM_USE_PARALLEL&quot;</span><span class="p">,</span> <span class="ow">not</span> <span class="n">numba</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">IS_32BITS</span><span class="p">)</span>


<div class="viewcode-block" id="make_toneburst">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.make_toneburst.html#arim.model.make_toneburst">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">make_toneburst</span><span class="p">(</span>
    <span class="n">num_cycles</span><span class="p">,</span> <span class="n">centre_freq</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">analytical</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a toneburst defined by centre frequency and a number of cycles.</span>

<span class="sd">    The signal is windowed by a Hann window (strictly zero outside the window). The</span>
<span class="sd">    toneburst is always symmetrical and its maximum is 1.0.</span>

<span class="sd">    With ``wrap=False``, the result is made up of (in this order) the toneburst then zeros</span>
<span class="sd">    (controlled by ``num_samples``).</span>
<span class="sd">    With ``wrap=True``, the result is made up of (in this order) the second half of the toneburst,</span>
<span class="sd">    then zeros, then the first half of the toneburst.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num_cycles : int</span>
<span class="sd">        Number of cycles of the toneburst.</span>
<span class="sd">    centre_freq : float</span>
<span class="sd">        Centre frequency</span>
<span class="sd">    dt : float</span>
<span class="sd">        Time step</span>
<span class="sd">    num_samples : int or None</span>
<span class="sd">        Number of time points. If None, returns a time vector that contains</span>
<span class="sd">        exactly the the toneburst. If larger, pads with zeros.</span>
<span class="sd">    wrap : bool, optional</span>
<span class="sd">        If False, the signal starts at n=0. If True, the signal is wrapped around such</span>
<span class="sd">         as its maximum is at n=0. The beginning of the signal is at the end of the vector.</span>
<span class="sd">         Default: False.</span>
<span class="sd">    analytical : bool, optional</span>
<span class="sd">        If True, returns the corresponding analytical signal (cos(...) + i sin(...)).</span>
<span class="sd">        Default: False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    toneburst : ndarray</span>
<span class="sd">        Array of length ``num_samples``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`make_toneburst2`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dt</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;negative time step&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">centre_freq</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;negative centre frequency&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_cycles</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;negative number of cycles&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num_samples</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;negative number of time samples&quot;</span><span class="p">)</span>

    <span class="n">len_pulse</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">num_cycles</span> <span class="o">/</span> <span class="n">centre_freq</span> <span class="o">/</span> <span class="n">dt</span><span class="p">))</span>
    <span class="c1"># force an odd length for pulse symmetry</span>
    <span class="k">if</span> <span class="n">len_pulse</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">len_pulse</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">half_len_window</span> <span class="o">=</span> <span class="n">len_pulse</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">num_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">num_samples</span> <span class="o">=</span> <span class="n">len_pulse</span>
    <span class="k">if</span> <span class="n">len_pulse</span> <span class="o">&gt;</span> <span class="n">num_samples</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;time vector is too short for this pulse&quot;</span><span class="p">)</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">len_pulse</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">analytical</span><span class="p">:</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">centre_freq</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">half_len_window</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">centre_freq</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">half_len_window</span><span class="p">))</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">len_pulse</span><span class="p">)</span>

    <span class="n">toneburst</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">*</span> <span class="n">window</span>
    <span class="n">full_toneburst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">toneburst</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">full_toneburst</span><span class="p">[:</span><span class="n">len_pulse</span><span class="p">]</span> <span class="o">=</span> <span class="n">toneburst</span>

    <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
        <span class="n">full_toneburst</span> <span class="o">=</span> <span class="n">_rotate_array</span><span class="p">(</span><span class="n">full_toneburst</span><span class="p">,</span> <span class="n">half_len_window</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">full_toneburst</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_rotate_array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; _rotate_array([1, 2, 3, 4, 5, 6, 7], 2)</span>
<span class="sd">    array([3, 4, 5, 6, 7, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; _rotate_array([1, 2, 3, 4, 5, 6, 7], -2)</span>
<span class="sd">    array([6, 7, 1, 2, 3, 4, 5])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">arr</span><span class="p">[</span><span class="n">n</span><span class="p">:],</span> <span class="n">arr</span><span class="p">[:</span><span class="n">n</span><span class="p">]])</span>


<div class="viewcode-block" id="make_toneburst2">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.make_toneburst2.html#arim.model.make_toneburst2">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">make_toneburst2</span><span class="p">(</span>
    <span class="n">num_cycles</span><span class="p">,</span>
    <span class="n">centre_freq</span><span class="p">,</span>
    <span class="n">dt</span><span class="p">,</span>
    <span class="n">num_before</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">num_after</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">analytical</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_fast_len</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a toneburst defined by centre frequency and a number of cycles.</span>

<span class="sd">    The result array is made up of (in this order) zeros (number controlled by ``num_before``),</span>
<span class="sd">    then the toneburst, then zeros (number controlled by ``num_after``).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num_cycles : int</span>
<span class="sd">        Number of cycles of the toneburst.</span>
<span class="sd">    centre_freq : float</span>
<span class="sd">        Centre frequency</span>
<span class="sd">    dt : float</span>
<span class="sd">        Time step</span>
<span class="sd">    num_before : int, optional</span>
<span class="sd">        Amount of zeros before the toneburst (in toneburst length).</span>
<span class="sd">    num_after : int, optional</span>
<span class="sd">        Amount of zeros after the toneburst (in toneburst length).</span>
<span class="sd">    analytical : bool, optional</span>
<span class="sd">    use_fast_len : bool, optional</span>
<span class="sd">        Use a FFT-friendly length (the default is True).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    toneburst_time : arim.core.Time</span>
<span class="sd">    toneburst : ndarray</span>
<span class="sd">    t0_idx : int</span>
<span class="sd">        Index of the time sample ``t=0``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`make_toneburst`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">signal</span> <span class="o">=</span> <span class="n">make_toneburst</span><span class="p">(</span>
        <span class="n">num_cycles</span><span class="p">,</span> <span class="n">centre_freq</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">analytical</span><span class="o">=</span><span class="n">analytical</span>
    <span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">num_before</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">num_after</span> <span class="o">*</span> <span class="n">n</span>

    <span class="n">toneburst_len</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="n">p</span>
    <span class="k">if</span> <span class="n">use_fast_len</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">scipy.fftpack</span>

        <span class="n">toneburst_len</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">fftpack</span><span class="o">.</span><span class="n">next_fast_len</span><span class="p">(</span><span class="n">toneburst_len</span><span class="p">)</span>
    <span class="n">toneburst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">toneburst_len</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">toneburst</span><span class="p">[</span><span class="n">m</span> <span class="p">:</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal</span>

    <span class="n">t0_idx</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">toneburst_time</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">Time</span><span class="p">(</span><span class="o">-</span><span class="n">t0_idx</span> <span class="o">*</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">toneburst</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">toneburst_time</span><span class="p">,</span> <span class="n">toneburst</span><span class="p">,</span> <span class="n">t0_idx</span></div>



<div class="viewcode-block" id="directivity_2d_rectangular_in_fluid">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.directivity_2d_rectangular_in_fluid.html#arim.model.directivity_2d_rectangular_in_fluid">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">directivity_2d_rectangular_in_fluid</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">element_width</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the directivity of an element based on the integration of uniformally radiating sources</span>
<span class="sd">    along a straight line in 2D.</span>

<span class="sd">    A element is modelled as &#39;rectangle&#39; of finite width and infinite length out-of-plane.</span>

<span class="sd">    This directivity is based only on the element width: each source is assumed to radiate</span>
<span class="sd">    uniformally.</span>

<span class="sd">    Considering a points1 in the axis Ox in the cartesian basis (O, x, y, z),</span>
<span class="sd">    ``theta`` is the inclination angle, ie. the angle in the plane Oxz. Cf. Wooh&#39;s paper.</span>

<span class="sd">    The directivity is normalised by the its maximum value, obtained for</span>
<span class="sd">    theta=0°.</span>

<span class="sd">    Returns:</span>

<span class="sd">        sinc(pi*a*sin(theta)/lambda)</span>

<span class="sd">    where: sinc(x) = sin(x)/x</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    theta : ndarray</span>
<span class="sd">        Angles in radians.</span>
<span class="sd">    element_width : float</span>
<span class="sd">        In meter.</span>
<span class="sd">    wavelength : float</span>
<span class="sd">        In meter.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    directivity : ndarray</span>
<span class="sd">        Signed directivity for each angle.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [Wooh]_</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`transmission_2d_rectangular_in_fluid`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">element_width</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Negative width&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">wavelength</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Negative wavelength&quot;</span><span class="p">)</span>

    <span class="c1"># /!\ numpy.sinc defines sinc(x) := sin(pi * x)/(pi * x)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">element_width</span> <span class="o">/</span> <span class="n">wavelength</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>



<div class="viewcode-block" id="directivity_2d_rectangular_in_fluid_for_path">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.directivity_2d_rectangular_in_fluid_for_path.html#arim.model.directivity_2d_rectangular_in_fluid_for_path">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">directivity_2d_rectangular_in_fluid_for_path</span><span class="p">(</span>
    <span class="n">ray_geometry</span><span class="p">,</span> <span class="n">element_width</span><span class="p">,</span> <span class="n">wavelength</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for :func:`directivity_2d_rectangular_in_fluid` that uses a</span>
<span class="sd">    :class:`RayGeometry` object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ray_geometry : arim.ray.RayGeometry</span>
<span class="sd">    element_width : float</span>
<span class="sd">    wavelength : float</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    directivity : ndarray</span>
<span class="sd">        Signed directivity for each angle.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">directivity_2d_rectangular_in_fluid</span><span class="p">(</span>
        <span class="n">ray_geometry</span><span class="o">.</span><span class="n">conventional_out_angle</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">element_width</span><span class="p">,</span> <span class="n">wavelength</span>
    <span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_f0</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k2</span><span class="p">):</span>
    <span class="c1"># Miller and Pursey 1954 eq (74)</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
    <span class="c1"># Warning: sqrt(a) * sqrt(b) != sqrt(a * b) because of negative values</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">k2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">x2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">k2</span><span class="p">)</span>


<div class="viewcode-block" id="directivity_2d_rectangular_on_solid_l">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.directivity_2d_rectangular_on_solid_l.html#arim.model.directivity_2d_rectangular_on_solid_l">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">directivity_2d_rectangular_on_solid_l</span><span class="p">(</span>
    <span class="n">theta</span><span class="p">,</span> <span class="n">element_width</span><span class="p">,</span> <span class="n">wavelength_l</span><span class="p">,</span> <span class="n">wavelength_t</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    L-wave directivity of rectangular element on solid</span>

<span class="sd">    The element is modelled by an infinitely long strip of finite width</span>
<span class="sd">    vibrating in a direction normal to the surface of the solid medium.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    theta : ndarray</span>
<span class="sd">        Angles in radians.</span>
<span class="sd">    element_width : float</span>
<span class="sd">    wavelength_l : float</span>
<span class="sd">    wavelength_t : float</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    directivity_l : ndarray</span>
<span class="sd">        Complex</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Equations Miller (93) and Drinkwater (2), (3), (6)</span>

<span class="sd">    The sinc results of the integration of Miller (90) with far field</span>
<span class="sd">    approximation.</span>

<span class="sd">    Normalisation coefficients are ignored, but the values are consistent with</span>
<span class="sd">    :func:`directivity_2d_rectangular_on_solid_t`.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [Drinkwater]_, [Miller]_</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`directivity_2d_rectangular_on_solid_t`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">wavelength_l</span> <span class="o">/</span> <span class="n">wavelength_t</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">k</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="p">((</span><span class="n">k2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">C</span><span class="p">)</span>
        <span class="o">/</span> <span class="n">_f0</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">k2</span><span class="p">)</span>
        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">((</span><span class="n">element_width</span> <span class="o">/</span> <span class="n">wavelength_l</span><span class="p">)</span> <span class="o">*</span> <span class="n">S</span><span class="p">)</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="directivity_2d_rectangular_on_solid_t">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.directivity_2d_rectangular_on_solid_t.html#arim.model.directivity_2d_rectangular_on_solid_t">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">directivity_2d_rectangular_on_solid_t</span><span class="p">(</span>
    <span class="n">theta</span><span class="p">,</span> <span class="n">element_width</span><span class="p">,</span> <span class="n">wavelength_l</span><span class="p">,</span> <span class="n">wavelength_t</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    T-wave directivity of rectangular element on solid</span>

<span class="sd">    See :func:`directivity_2d_rectangular_on_solid_l` for further information.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    theta : ndarray</span>
<span class="sd">        Angles in radians.</span>
<span class="sd">    element_width : float</span>
<span class="sd">    wavelength_l : float</span>
<span class="sd">    wavelength_t : float</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    directivity_t : ndarray</span>
<span class="sd">        Complex</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Equations Miller (94) and Drinkwater (2), (4), (6)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [Drinkwater]_, [Miller]_</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`directivity_2d_rectangular_on_solid_t`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">wavelength_l</span> <span class="o">/</span> <span class="n">wavelength_t</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">k</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">k</span><span class="o">**</span><span class="mf">2.5</span>
        <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k2</span> <span class="o">*</span> <span class="n">S</span> <span class="o">*</span> <span class="n">S</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">theta</span><span class="p">))</span>
        <span class="o">/</span> <span class="n">_f0</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">S</span><span class="p">,</span> <span class="n">k2</span><span class="p">)</span>
        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">((</span><span class="n">element_width</span> <span class="o">/</span> <span class="n">wavelength_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">S</span><span class="p">)</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="snell_angles">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.snell_angles.html#arim.model.snell_angles">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">snell_angles</span><span class="p">(</span><span class="n">incidents_angles</span><span class="p">,</span> <span class="n">c_incident</span><span class="p">,</span> <span class="n">c_refracted</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the angles of the refracted rays according to Snell–Descartes law:</span>

<span class="sd">        c1/c2 = sin(alpha1)/sin(alpha2)</span>

<span class="sd">    In case of total internal reflection (incident angles above the critical angles), the output depends</span>
<span class="sd">    on the datatype of the incident angle.</span>
<span class="sd">    If the incident angle is real, the refracted angle is &quot;not a number&quot;.</span>
<span class="sd">    If the incident angle is complex, the refracted angle is complex (imagery part not null).</span>
<span class="sd">    The reason is that either the real or the complex arcsine function is used.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">c_refracted</span> <span class="o">/</span> <span class="n">c_incident</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">incidents_angles</span><span class="p">))</span></div>



<div class="viewcode-block" id="fluid_solid">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.fluid_solid.html#arim.model.fluid_solid">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fluid_solid</span><span class="p">(</span>
    <span class="n">alpha_fluid</span><span class="p">,</span> <span class="n">rho_fluid</span><span class="p">,</span> <span class="n">rho_solid</span><span class="p">,</span> <span class="n">c_fluid</span><span class="p">,</span> <span class="n">c_l</span><span class="p">,</span> <span class="n">c_t</span><span class="p">,</span> <span class="n">alpha_l</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha_t</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the transmission and reflection coefficients for an incident wave at a fluid-to-solid interface.</span>

<span class="sd">    The coefficients are expressed as pressure/stress ratio. All angles are in radians.</span>
<span class="sd">    The angles are relative to the normal of the interface.</span>

<span class="sd">    Cf. equations (A7), (A8), (A9) from Krautkrämer.</span>

<span class="sd">    Caveat: in case of total reflection, using complex angles should be considered.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    alpha_fluid : ndarray</span>
<span class="sd">        Angles of the incident wave in the fluid.</span>
<span class="sd">    rho_fluid : float</span>
<span class="sd">        Density of the fluid.</span>
<span class="sd">    rho_solid : float</span>
<span class="sd">        Density of the solid.</span>
<span class="sd">    c_fluid : float</span>
<span class="sd">        Speed of sound in the fluid.</span>
<span class="sd">    c_l : float</span>
<span class="sd">        Speed of the longitudinal wave in the solid.</span>
<span class="sd">    c_t : float</span>
<span class="sd">        Speed of the transverse wave in the solid.</span>
<span class="sd">    alpha_l : ndarray or None</span>
<span class="sd">        Angles of the transmitted longitudinal wave in the solid. If None: compute it on the fly with Snell-Descartes laws.</span>
<span class="sd">    alpha_t : ndarray or None</span>
<span class="sd">        Angles of the transmitted transverse wave in the solid. If None: compute it on the fly with Snell-Descartes laws.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reflection : ndarray</span>
<span class="sd">        Reflection coefficient</span>
<span class="sd">    transmission_l : ndarray</span>
<span class="sd">        Transmission coefficient of the longitudinal wave</span>
<span class="sd">    transmission_l : ndarray</span>
<span class="sd">        Reflection coefficient of the longitudinal wave</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [KK]_</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alpha_fluid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">alpha_fluid</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">alpha_l</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">alpha_l</span> <span class="o">=</span> <span class="n">snell_angles</span><span class="p">(</span><span class="n">alpha_fluid</span><span class="p">,</span> <span class="n">c_fluid</span><span class="p">,</span> <span class="n">c_l</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">alpha_t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">alpha_t</span> <span class="o">=</span> <span class="n">snell_angles</span><span class="p">(</span><span class="n">alpha_fluid</span><span class="p">,</span> <span class="n">c_fluid</span><span class="p">,</span> <span class="n">c_t</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">_fluid_solid_n</span><span class="p">(</span>
        <span class="n">alpha_fluid</span><span class="p">,</span> <span class="n">alpha_l</span><span class="p">,</span> <span class="n">alpha_t</span><span class="p">,</span> <span class="n">rho_fluid</span><span class="p">,</span> <span class="n">rho_solid</span><span class="p">,</span> <span class="n">c_fluid</span><span class="p">,</span> <span class="n">c_l</span><span class="p">,</span> <span class="n">c_t</span>
    <span class="p">)</span>

    <span class="c1"># Eq A.7</span>
    <span class="n">ct_cl2</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_t</span> <span class="o">*</span> <span class="n">c_t</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c_l</span> <span class="o">*</span> <span class="n">c_l</span><span class="p">)</span>
    <span class="n">cos_2_alpha_t</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha_t</span><span class="p">)</span>

    <span class="n">reflection</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">ct_cl2</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha_l</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha_t</span><span class="p">)</span>
        <span class="o">+</span> <span class="n">cos_2_alpha_t</span> <span class="o">*</span> <span class="n">cos_2_alpha_t</span>
        <span class="o">-</span> <span class="p">(</span><span class="n">rho_fluid</span> <span class="o">*</span> <span class="n">c_fluid</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha_l</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">rho_solid</span> <span class="o">*</span> <span class="n">c_l</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha_fluid</span><span class="p">))</span>
    <span class="p">)</span> <span class="o">/</span> <span class="n">N</span>

    <span class="c1"># Eq A.8</span>
    <span class="n">transmission_l</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">cos_2_alpha_t</span> <span class="o">/</span> <span class="n">N</span>

    <span class="c1"># Eq A.9</span>
    <span class="n">transmission_t</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">ct_cl2</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha_l</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>

    <span class="k">return</span> <span class="n">reflection</span><span class="p">,</span> <span class="n">transmission_l</span><span class="p">,</span> <span class="n">transmission_t</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_fluid_solid_n</span><span class="p">(</span>
    <span class="n">alpha_fluid</span><span class="p">,</span> <span class="n">alpha_l</span><span class="p">,</span> <span class="n">alpha_t</span><span class="p">,</span> <span class="n">rho_fluid</span><span class="p">,</span> <span class="n">rho_solid</span><span class="p">,</span> <span class="n">c_fluid</span><span class="p">,</span> <span class="n">c_l</span><span class="p">,</span> <span class="n">c_t</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Coefficient N defined by Krautkrämer in equation (A8).&quot;&quot;&quot;</span>
    <span class="n">ct_cl2</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_t</span> <span class="o">*</span> <span class="n">c_t</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c_l</span> <span class="o">*</span> <span class="n">c_l</span><span class="p">)</span>
    <span class="n">cos_2_alpha_t</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha_t</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">ct_cl2</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha_l</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha_t</span><span class="p">)</span>
        <span class="o">+</span> <span class="n">cos_2_alpha_t</span> <span class="o">*</span> <span class="n">cos_2_alpha_t</span>
        <span class="o">+</span> <span class="n">rho_fluid</span> <span class="o">*</span> <span class="n">c_fluid</span> <span class="o">/</span> <span class="p">(</span><span class="n">rho_solid</span> <span class="o">*</span> <span class="n">c_l</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha_l</span><span class="p">)</span> <span class="o">/</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha_fluid</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">N</span>


<div class="viewcode-block" id="solid_l_fluid">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.solid_l_fluid.html#arim.model.solid_l_fluid">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">solid_l_fluid</span><span class="p">(</span>
    <span class="n">alpha_l</span><span class="p">,</span> <span class="n">rho_fluid</span><span class="p">,</span> <span class="n">rho_solid</span><span class="p">,</span> <span class="n">c_fluid</span><span class="p">,</span> <span class="n">c_l</span><span class="p">,</span> <span class="n">c_t</span><span class="p">,</span> <span class="n">alpha_fluid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha_t</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the transmission and reflection coefficients for an incident longitudinal wave at a solid-to-fluid interface.</span>

<span class="sd">    The coefficients are expressed as pressure/stress ratio. All angles are in radians.</span>
<span class="sd">    The angles are relative to the normal of the interface.</span>

<span class="sd">    Cf. equations (A7), (A8), (A9) from Krautkrämer.</span>

<span class="sd">    Caveat: in case of total reflection, using complex angles should be considered.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    alpha_l : ndarray</span>
<span class="sd">        Angles of the incident longitudinal wave in the solid.</span>
<span class="sd">    rho_fluid : float</span>
<span class="sd">        Density of the fluid.</span>
<span class="sd">    rho_solid : float</span>
<span class="sd">        Density of the solid.</span>
<span class="sd">    c_fluid : float</span>
<span class="sd">        Speed of sound in the fluid.</span>
<span class="sd">    c_l : float</span>
<span class="sd">        Speed of the longitudinal wave in the solid.</span>
<span class="sd">    c_t : float</span>
<span class="sd">        Speed of the transverse wave in the solid.</span>
<span class="sd">    alpha_fluid : ndarray or None</span>
<span class="sd">        Angles of the transmitted wave in the fluid. If None: compute it on the fly with Snell-Descartes laws.</span>
<span class="sd">    alpha_t : ndarray or None</span>
<span class="sd">        Angles of the incident transverse wave in the solid. If None: compute it on the fly with Snell-Descartes laws.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reflection_l : ndarray</span>
<span class="sd">        Reflection coefficient of the longitudinal wave</span>
<span class="sd">    reflection_t : ndarray</span>
<span class="sd">        Reflection coefficient of the transverse wave</span>
<span class="sd">    transmission : ndarray</span>
<span class="sd">        Transmission coefficient</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [KK]_</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">alpha_fluid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">alpha_fluid</span> <span class="o">=</span> <span class="n">snell_angles</span><span class="p">(</span><span class="n">alpha_l</span><span class="p">,</span> <span class="n">c_l</span><span class="p">,</span> <span class="n">c_fluid</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">alpha_t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">alpha_t</span> <span class="o">=</span> <span class="n">snell_angles</span><span class="p">(</span><span class="n">alpha_l</span><span class="p">,</span> <span class="n">c_l</span><span class="p">,</span> <span class="n">c_t</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">_fluid_solid_n</span><span class="p">(</span>
        <span class="n">alpha_fluid</span><span class="p">,</span> <span class="n">alpha_l</span><span class="p">,</span> <span class="n">alpha_t</span><span class="p">,</span> <span class="n">rho_fluid</span><span class="p">,</span> <span class="n">rho_solid</span><span class="p">,</span> <span class="n">c_fluid</span><span class="p">,</span> <span class="n">c_l</span><span class="p">,</span> <span class="n">c_t</span>
    <span class="p">)</span>

    <span class="c1"># Eq A.10</span>
    <span class="n">ct_cl2</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_t</span> <span class="o">*</span> <span class="n">c_t</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c_l</span> <span class="o">*</span> <span class="n">c_l</span><span class="p">)</span>
    <span class="n">cos_2_alpha_t</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha_t</span><span class="p">)</span>
    <span class="n">reflection_l</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">ct_cl2</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha_l</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha_t</span><span class="p">)</span>
        <span class="o">-</span> <span class="n">cos_2_alpha_t</span> <span class="o">*</span> <span class="n">cos_2_alpha_t</span>
        <span class="o">+</span> <span class="n">rho_fluid</span> <span class="o">*</span> <span class="n">c_fluid</span> <span class="o">/</span> <span class="p">(</span><span class="n">rho_solid</span> <span class="o">*</span> <span class="n">c_l</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha_l</span><span class="p">)</span> <span class="o">/</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha_fluid</span><span class="p">)</span>
    <span class="p">)</span> <span class="o">/</span> <span class="n">N</span>

    <span class="c1"># Eq A.11</span>
    <span class="n">reflection_t</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ct_cl2</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha_l</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha_t</span><span class="p">))</span> <span class="o">/</span> <span class="n">N</span>

    <span class="c1"># Eq A.12</span>
    <span class="n">transmission</span> <span class="o">=</span> <span class="p">(</span>
        <span class="mi">2</span>
        <span class="o">*</span> <span class="n">rho_fluid</span>
        <span class="o">*</span> <span class="n">c_fluid</span>
        <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha_l</span><span class="p">)</span>
        <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha_t</span><span class="p">)</span>
        <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">rho_solid</span> <span class="o">*</span> <span class="n">c_l</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha_fluid</span><span class="p">))</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">reflection_l</span><span class="p">,</span> <span class="n">reflection_t</span><span class="p">,</span> <span class="n">transmission</span></div>



<div class="viewcode-block" id="solid_t_fluid">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.solid_t_fluid.html#arim.model.solid_t_fluid">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">solid_t_fluid</span><span class="p">(</span>
    <span class="n">alpha_t</span><span class="p">,</span> <span class="n">rho_fluid</span><span class="p">,</span> <span class="n">rho_solid</span><span class="p">,</span> <span class="n">c_fluid</span><span class="p">,</span> <span class="n">c_l</span><span class="p">,</span> <span class="n">c_t</span><span class="p">,</span> <span class="n">alpha_fluid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha_l</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the transmission and reflection coefficients for an incident transverse wave at a solid-to-fluid interface.</span>

<span class="sd">    The coefficients are expressed as pressure/stress ratio. All angles are in radians.</span>
<span class="sd">    The angles are relative to the normal of the interface.</span>

<span class="sd">    Cf. equations (A7), (A8), (A9) from Krautkrämer.</span>

<span class="sd">    Caveat: in case of total reflection, using complex angles should be considered.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    alpha_t : ndarray</span>
<span class="sd">        Angles of the incident transverse wave in the solid.</span>
<span class="sd">    rho_fluid : float</span>
<span class="sd">        Density of the fluid.</span>
<span class="sd">    rho_solid : float</span>
<span class="sd">        Density of the solid.</span>
<span class="sd">    c_fluid : float</span>
<span class="sd">        Speed of sound in the fluid.</span>
<span class="sd">    c_l : float</span>
<span class="sd">        Speed of the longitudinal wave in the solid.</span>
<span class="sd">    c_t : float</span>
<span class="sd">        Speed of the transverse wave in the solid.</span>
<span class="sd">    alpha_fluid : ndarray or None</span>
<span class="sd">        Angles of the transmitted wave in the fluid. If None: compute it on the fly with Snell-Descartes laws.</span>
<span class="sd">    alpha_l : ndarray or None</span>
<span class="sd">        Angles of the incident longitudinal wave in the solid. If None: compute it on the fly with Snell-Descartes laws.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reflection_l : ndarray</span>
<span class="sd">        Reflection coefficient of the longitudinal wave</span>
<span class="sd">    reflection_t : ndarray</span>
<span class="sd">        Reflection coefficient of the transverse wave</span>
<span class="sd">    transmission : ndarray</span>
<span class="sd">        Transmission coefficient</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [KK]_</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">alpha_fluid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">alpha_fluid</span> <span class="o">=</span> <span class="n">snell_angles</span><span class="p">(</span><span class="n">alpha_t</span><span class="p">,</span> <span class="n">c_t</span><span class="p">,</span> <span class="n">c_fluid</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">alpha_l</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">alpha_l</span> <span class="o">=</span> <span class="n">snell_angles</span><span class="p">(</span><span class="n">alpha_t</span><span class="p">,</span> <span class="n">c_t</span><span class="p">,</span> <span class="n">c_l</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">_fluid_solid_n</span><span class="p">(</span>
        <span class="n">alpha_fluid</span><span class="p">,</span> <span class="n">alpha_l</span><span class="p">,</span> <span class="n">alpha_t</span><span class="p">,</span> <span class="n">rho_fluid</span><span class="p">,</span> <span class="n">rho_solid</span><span class="p">,</span> <span class="n">c_fluid</span><span class="p">,</span> <span class="n">c_l</span><span class="p">,</span> <span class="n">c_t</span>
    <span class="p">)</span>

    <span class="c1"># Eq A.14</span>
    <span class="n">reflection_l</span> <span class="o">=</span> <span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">alpha_t</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>

    <span class="c1"># Eq A.13</span>
    <span class="n">ct_cl2</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_t</span> <span class="o">*</span> <span class="n">c_t</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c_l</span> <span class="o">*</span> <span class="n">c_l</span><span class="p">)</span>
    <span class="n">cos_2_alpha_t</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha_t</span><span class="p">)</span>
    <span class="n">reflection_t</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">ct_cl2</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha_l</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha_t</span><span class="p">)</span>
        <span class="o">-</span> <span class="n">cos_2_alpha_t</span> <span class="o">*</span> <span class="n">cos_2_alpha_t</span>
        <span class="o">-</span> <span class="n">rho_fluid</span> <span class="o">*</span> <span class="n">c_fluid</span> <span class="o">/</span> <span class="p">(</span><span class="n">rho_solid</span> <span class="o">*</span> <span class="n">c_l</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha_l</span><span class="p">)</span> <span class="o">/</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha_fluid</span><span class="p">)</span>
    <span class="p">)</span> <span class="o">/</span> <span class="n">N</span>

    <span class="c1"># Eq A.15</span>
    <span class="n">transmission</span> <span class="o">=</span> <span class="p">(</span>
        <span class="mi">2</span>
        <span class="o">*</span> <span class="n">rho_fluid</span>
        <span class="o">*</span> <span class="n">c_fluid</span>
        <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha_l</span><span class="p">)</span>
        <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha_t</span><span class="p">)</span>
        <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">rho_solid</span> <span class="o">*</span> <span class="n">c_l</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha_fluid</span><span class="p">))</span>
    <span class="p">)</span>

    <span class="c1"># TODO: Rose in &quot;Ultrasonic guided waves in solid media&quot; gives the oppositeof these</span>
    <span class="c1"># coefficients. Fix this?</span>
    <span class="k">return</span> <span class="n">reflection_l</span><span class="p">,</span> <span class="n">reflection_t</span><span class="p">,</span> <span class="n">transmission</span></div>



<div class="viewcode-block" id="transmission_at_interface">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.transmission_at_interface.html#arim.model.transmission_at_interface">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">transmission_at_interface</span><span class="p">(</span>
    <span class="n">interface_kind</span><span class="p">,</span>
    <span class="n">material_inc</span><span class="p">,</span>
    <span class="n">material_out</span><span class="p">,</span>
    <span class="n">mode_inc</span><span class="p">,</span>
    <span class="n">mode_out</span><span class="p">,</span>
    <span class="n">angles_inc</span><span class="p">,</span>
    <span class="n">force_complex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;stress&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the transmission coefficients for an interface.</span>

<span class="sd">    The angles of transmission or reflection are obtained using Snell-Descartes laws</span>
<span class="sd">    (:func:`snell_angles`).</span>
<span class="sd">    Warning: do not check whether the angles of incidence are physical.</span>

<span class="sd">    Warning: only fluid-to-solid interface is implemented yet.</span>

<span class="sd">    TODO: write test.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    interface_kind : InterfaceKind</span>
<span class="sd">    material_inc : arim.Material</span>
<span class="sd">        Material of the incident ray legs.</span>
<span class="sd">    material_out : arim.Material</span>
<span class="sd">        Material of the transmitted ray legs.</span>
<span class="sd">    mode_inc : Mode</span>
<span class="sd">        Mode of the incidents ray legs.</span>
<span class="sd">    mode_out : Mode</span>
<span class="sd">        Mode of the transmitted ray legs.</span>
<span class="sd">    angles_inc : ndarray</span>
<span class="sd">        Angle of incidence of the ray legs.</span>
<span class="sd">    force_complex : bool</span>
<span class="sd">        If True, return complex coefficients. If not, return coefficients with the same datatype as ``angles_inc``. Default: True.</span>
<span class="sd">    unit : str</span>
<span class="sd">        &#39;stress&#39; or &#39;displacement&#39;. Default: &#39;stress&#39;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    amps : ndarray</span>
<span class="sd">        ``amps[i, j]`` is the transmission coefficient for the ray (i, j) at the given interface.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [KK]_</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">force_complex</span><span class="p">:</span>
        <span class="n">angles_inc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">angles_inc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">unit</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;stress&quot;</span><span class="p">:</span>
        <span class="n">convert_to_displacement</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="n">unit</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;displacement&quot;</span><span class="p">:</span>
        <span class="n">convert_to_displacement</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument &#39;unit&#39; must be &#39;stress&#39; or &#39;displacement&#39;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">interface_kind</span> <span class="ow">is</span> <span class="n">c</span><span class="o">.</span><span class="n">InterfaceKind</span><span class="o">.</span><span class="n">fluid_solid</span><span class="p">:</span>
        <span class="c1"># Fluid-solid interface in transmission</span>
        <span class="c1">#   &quot;in&quot; is in the fluid</span>
        <span class="c1">#   &quot;out&quot; is in the solid</span>
        <span class="k">assert</span> <span class="n">mode_inc</span> <span class="ow">is</span> <span class="n">c</span><span class="o">.</span><span class="n">Mode</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="s2">&quot;you&#39;ve broken the physics&quot;</span>

        <span class="n">fluid</span> <span class="o">=</span> <span class="n">material_inc</span>
        <span class="n">solid</span> <span class="o">=</span> <span class="n">material_out</span>
        <span class="k">assert</span> <span class="n">solid</span><span class="o">.</span><span class="n">state_of_matter</span> <span class="o">==</span> <span class="n">c</span><span class="o">.</span><span class="n">StateMatter</span><span class="o">.</span><span class="n">solid</span>
        <span class="k">assert</span> <span class="n">fluid</span><span class="o">.</span><span class="n">state_of_matter</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">c</span><span class="o">.</span><span class="n">StateMatter</span><span class="o">.</span><span class="n">solid</span>

        <span class="n">alpha_fluid</span> <span class="o">=</span> <span class="n">angles_inc</span>
        <span class="n">alpha_l</span> <span class="o">=</span> <span class="n">snell_angles</span><span class="p">(</span>
            <span class="n">alpha_fluid</span><span class="p">,</span> <span class="n">fluid</span><span class="o">.</span><span class="n">longitudinal_vel</span><span class="p">,</span> <span class="n">solid</span><span class="o">.</span><span class="n">longitudinal_vel</span>
        <span class="p">)</span>
        <span class="n">alpha_t</span> <span class="o">=</span> <span class="n">snell_angles</span><span class="p">(</span>
            <span class="n">alpha_fluid</span><span class="p">,</span> <span class="n">fluid</span><span class="o">.</span><span class="n">longitudinal_vel</span><span class="p">,</span> <span class="n">solid</span><span class="o">.</span><span class="n">transverse_vel</span>
        <span class="p">)</span>

        <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">alpha_fluid</span><span class="o">=</span><span class="n">alpha_fluid</span><span class="p">,</span>
            <span class="n">alpha_l</span><span class="o">=</span><span class="n">alpha_l</span><span class="p">,</span>
            <span class="n">alpha_t</span><span class="o">=</span><span class="n">alpha_t</span><span class="p">,</span>
            <span class="n">rho_fluid</span><span class="o">=</span><span class="n">fluid</span><span class="o">.</span><span class="n">density</span><span class="p">,</span>
            <span class="n">rho_solid</span><span class="o">=</span><span class="n">solid</span><span class="o">.</span><span class="n">density</span><span class="p">,</span>
            <span class="n">c_fluid</span><span class="o">=</span><span class="n">fluid</span><span class="o">.</span><span class="n">longitudinal_vel</span><span class="p">,</span>
            <span class="n">c_l</span><span class="o">=</span><span class="n">solid</span><span class="o">.</span><span class="n">longitudinal_vel</span><span class="p">,</span>
            <span class="n">c_t</span><span class="o">=</span><span class="n">solid</span><span class="o">.</span><span class="n">transverse_vel</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">refl</span><span class="p">,</span> <span class="n">trans_l</span><span class="p">,</span> <span class="n">trans_t</span> <span class="o">=</span> <span class="n">fluid_solid</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">convert_to_displacement</span><span class="p">:</span>
            <span class="c1"># u2/u1 = z tau2 / tau1 = -z tau2 / p1</span>
            <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">material_inc</span><span class="o">.</span><span class="n">density</span> <span class="o">*</span> <span class="n">material_inc</span><span class="o">.</span><span class="n">velocity</span><span class="p">(</span><span class="n">mode_inc</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span>
                <span class="n">material_out</span><span class="o">.</span><span class="n">density</span> <span class="o">*</span> <span class="n">material_out</span><span class="o">.</span><span class="n">velocity</span><span class="p">(</span><span class="n">mode_out</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">trans_l</span> <span class="o">*=</span> <span class="n">z</span>
            <span class="n">trans_t</span> <span class="o">*=</span> <span class="n">z</span>
        <span class="k">if</span> <span class="n">mode_out</span> <span class="ow">is</span> <span class="n">c</span><span class="o">.</span><span class="n">Mode</span><span class="o">.</span><span class="n">L</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">trans_l</span>
        <span class="k">elif</span> <span class="n">mode_out</span> <span class="ow">is</span> <span class="n">c</span><span class="o">.</span><span class="n">Mode</span><span class="o">.</span><span class="n">T</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">trans_t</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid mode&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">interface_kind</span> <span class="ow">is</span> <span class="n">c</span><span class="o">.</span><span class="n">InterfaceKind</span><span class="o">.</span><span class="n">solid_fluid</span><span class="p">:</span>
        <span class="c1"># Fluid-solid interface in transmission</span>
        <span class="c1">#   &quot;in&quot; is in the solid</span>
        <span class="c1">#   &quot;out&quot; is in the fluid</span>
        <span class="k">assert</span> <span class="n">mode_out</span> <span class="ow">is</span> <span class="n">c</span><span class="o">.</span><span class="n">Mode</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="s2">&quot;you&#39;ve broken the physics&quot;</span>

        <span class="n">solid</span> <span class="o">=</span> <span class="n">material_inc</span>
        <span class="n">fluid</span> <span class="o">=</span> <span class="n">material_out</span>
        <span class="k">assert</span> <span class="n">solid</span><span class="o">.</span><span class="n">state_of_matter</span> <span class="o">==</span> <span class="n">c</span><span class="o">.</span><span class="n">StateMatter</span><span class="o">.</span><span class="n">solid</span>
        <span class="k">assert</span> <span class="n">fluid</span><span class="o">.</span><span class="n">state_of_matter</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">c</span><span class="o">.</span><span class="n">StateMatter</span><span class="o">.</span><span class="n">solid</span>

        <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">rho_fluid</span><span class="o">=</span><span class="n">fluid</span><span class="o">.</span><span class="n">density</span><span class="p">,</span>
            <span class="n">rho_solid</span><span class="o">=</span><span class="n">solid</span><span class="o">.</span><span class="n">density</span><span class="p">,</span>
            <span class="n">c_fluid</span><span class="o">=</span><span class="n">fluid</span><span class="o">.</span><span class="n">longitudinal_vel</span><span class="p">,</span>
            <span class="n">c_l</span><span class="o">=</span><span class="n">solid</span><span class="o">.</span><span class="n">longitudinal_vel</span><span class="p">,</span>
            <span class="n">c_t</span><span class="o">=</span><span class="n">solid</span><span class="o">.</span><span class="n">transverse_vel</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">mode_inc</span> <span class="ow">is</span> <span class="n">c</span><span class="o">.</span><span class="n">Mode</span><span class="o">.</span><span class="n">L</span><span class="p">:</span>
            <span class="n">alpha_l</span> <span class="o">=</span> <span class="n">angles_inc</span>
            <span class="n">refl_l</span><span class="p">,</span> <span class="n">refl_t</span><span class="p">,</span> <span class="n">transmission</span> <span class="o">=</span> <span class="n">solid_l_fluid</span><span class="p">(</span><span class="n">alpha_l</span><span class="o">=</span><span class="n">alpha_l</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode_inc</span> <span class="ow">is</span> <span class="n">c</span><span class="o">.</span><span class="n">Mode</span><span class="o">.</span><span class="n">T</span><span class="p">:</span>
            <span class="n">alpha_t</span> <span class="o">=</span> <span class="n">angles_inc</span>
            <span class="n">refl_l</span><span class="p">,</span> <span class="n">refl_t</span><span class="p">,</span> <span class="n">transmission</span> <span class="o">=</span> <span class="n">solid_t_fluid</span><span class="p">(</span><span class="n">alpha_t</span><span class="o">=</span><span class="n">alpha_t</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span>
        <span class="k">if</span> <span class="n">convert_to_displacement</span><span class="p">:</span>
            <span class="c1"># u2/u1 = z tau2 / tau1 = -z tau2 / p1</span>
            <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">material_inc</span><span class="o">.</span><span class="n">density</span> <span class="o">*</span> <span class="n">material_inc</span><span class="o">.</span><span class="n">velocity</span><span class="p">(</span><span class="n">mode_inc</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span>
                <span class="n">material_out</span><span class="o">.</span><span class="n">density</span> <span class="o">*</span> <span class="n">material_out</span><span class="o">.</span><span class="n">velocity</span><span class="p">(</span><span class="n">mode_out</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">transmission</span> <span class="o">*=</span> <span class="n">z</span>
        <span class="k">return</span> <span class="n">transmission</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>



<div class="viewcode-block" id="reflection_at_interface">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.reflection_at_interface.html#arim.model.reflection_at_interface">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">reflection_at_interface</span><span class="p">(</span>
    <span class="n">interface_kind</span><span class="p">,</span>
    <span class="n">material_inc</span><span class="p">,</span>
    <span class="n">material_against</span><span class="p">,</span>
    <span class="n">mode_inc</span><span class="p">,</span>
    <span class="n">mode_out</span><span class="p">,</span>
    <span class="n">angles_inc</span><span class="p">,</span>
    <span class="n">force_complex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;stress&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the reflection coefficients for an interface.</span>

<span class="sd">    The angles of transmission or reflection are obtained using Snell-Descartes laws</span>
<span class="sd">    (:func:`snell_angles`).</span>
<span class="sd">    Warning: do not check whether the angles of incidence are physical.</span>

<span class="sd">    Warning: only fluid-to-solid interface is implemented yet.</span>

<span class="sd">    TODO: write test.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    interface_kind : InterfaceKind</span>
<span class="sd">    material_inc : Material</span>
<span class="sd">        Material of the incident ray legs.</span>
<span class="sd">    material_against : Material</span>
<span class="sd">        Material of the reflected ray legs.</span>
<span class="sd">    mode_inc : Mode</span>
<span class="sd">        Mode of the incidents ray legs.</span>
<span class="sd">    mode_out : Mode</span>
<span class="sd">        Mode of the transmitted ray legs.</span>
<span class="sd">    angles_inc : ndarray</span>
<span class="sd">        Angle of incidence of the ray legs.</span>
<span class="sd">    force_complex : bool</span>
<span class="sd">        If True, return complex coefficients. If not, return coefficients with the same</span>
<span class="sd">        datatype as ``angles_inc``. Default: True.</span>
<span class="sd">    unit : str</span>
<span class="sd">        &#39;stress&#39; or &#39;displacement&#39;. Default: &#39;stress&#39;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    amps : ndarray</span>
<span class="sd">        ``amps[i, j]`` is the reflection coefficient for the ray (i, j) at the given interface.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [KK]_</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">force_complex</span><span class="p">:</span>
        <span class="n">angles_inc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">angles_inc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">unit</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;stress&quot;</span><span class="p">:</span>
        <span class="n">convert_to_displacement</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="n">unit</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;displacement&quot;</span><span class="p">:</span>
        <span class="n">convert_to_displacement</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument &#39;unit&#39; must be &#39;stress&#39; or &#39;displacement&#39;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">interface_kind</span> <span class="ow">is</span> <span class="n">c</span><span class="o">.</span><span class="n">InterfaceKind</span><span class="o">.</span><span class="n">solid_fluid</span><span class="p">:</span>
        <span class="c1"># Reflection against a solid-fluid interface</span>
        <span class="c1">#   &quot;in&quot; is in the solid</span>
        <span class="c1">#   &quot;out&quot; is also in the solid</span>
        <span class="n">solid</span> <span class="o">=</span> <span class="n">material_inc</span>
        <span class="n">fluid</span> <span class="o">=</span> <span class="n">material_against</span>
        <span class="k">assert</span> <span class="n">solid</span><span class="o">.</span><span class="n">state_of_matter</span> <span class="o">==</span> <span class="n">c</span><span class="o">.</span><span class="n">StateMatter</span><span class="o">.</span><span class="n">solid</span>
        <span class="k">assert</span> <span class="n">fluid</span><span class="o">.</span><span class="n">state_of_matter</span> <span class="o">!=</span> <span class="n">c</span><span class="o">.</span><span class="n">StateMatter</span><span class="o">.</span><span class="n">solid</span>

        <span class="k">if</span> <span class="n">mode_inc</span> <span class="ow">is</span> <span class="n">c</span><span class="o">.</span><span class="n">Mode</span><span class="o">.</span><span class="n">L</span><span class="p">:</span>
            <span class="n">angles_l</span> <span class="o">=</span> <span class="n">angles_inc</span>
            <span class="n">angles_t</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">solid_fluid</span> <span class="o">=</span> <span class="n">solid_l_fluid</span>
        <span class="k">elif</span> <span class="n">mode_inc</span> <span class="ow">is</span> <span class="n">c</span><span class="o">.</span><span class="n">Mode</span><span class="o">.</span><span class="n">T</span><span class="p">:</span>
            <span class="n">angles_l</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">angles_t</span> <span class="o">=</span> <span class="n">angles_inc</span>
            <span class="n">solid_fluid</span> <span class="o">=</span> <span class="n">solid_t_fluid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid mode&quot;</span><span class="p">)</span>

        <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">alpha_fluid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">alpha_l</span><span class="o">=</span><span class="n">angles_l</span><span class="p">,</span>
            <span class="n">alpha_t</span><span class="o">=</span><span class="n">angles_t</span><span class="p">,</span>
            <span class="n">rho_fluid</span><span class="o">=</span><span class="n">fluid</span><span class="o">.</span><span class="n">density</span><span class="p">,</span>
            <span class="n">rho_solid</span><span class="o">=</span><span class="n">solid</span><span class="o">.</span><span class="n">density</span><span class="p">,</span>
            <span class="n">c_fluid</span><span class="o">=</span><span class="n">fluid</span><span class="o">.</span><span class="n">longitudinal_vel</span><span class="p">,</span>
            <span class="n">c_l</span><span class="o">=</span><span class="n">solid</span><span class="o">.</span><span class="n">longitudinal_vel</span><span class="p">,</span>
            <span class="n">c_t</span><span class="o">=</span><span class="n">solid</span><span class="o">.</span><span class="n">transverse_vel</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
            <span class="n">refl_l</span><span class="p">,</span> <span class="n">refl_t</span><span class="p">,</span> <span class="n">trans</span> <span class="o">=</span> <span class="n">solid_fluid</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>

        <span class="n">z</span> <span class="o">=</span> <span class="n">material_inc</span><span class="o">.</span><span class="n">velocity</span><span class="p">(</span><span class="n">mode_inc</span><span class="p">)</span> <span class="o">/</span> <span class="n">material_inc</span><span class="o">.</span><span class="n">velocity</span><span class="p">(</span><span class="n">mode_out</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode_out</span> <span class="ow">is</span> <span class="n">c</span><span class="o">.</span><span class="n">Mode</span><span class="o">.</span><span class="n">L</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">convert_to_displacement</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">refl_l</span> <span class="o">*</span> <span class="n">z</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">refl_l</span>
        <span class="k">elif</span> <span class="n">mode_out</span> <span class="ow">is</span> <span class="n">c</span><span class="o">.</span><span class="n">Mode</span><span class="o">.</span><span class="n">T</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">convert_to_displacement</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">refl_t</span> <span class="o">*</span> <span class="n">z</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">refl_t</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid mode&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">interface_kind</span> <span class="ow">is</span> <span class="n">c</span><span class="o">.</span><span class="n">InterfaceKind</span><span class="o">.</span><span class="n">fluid_solid</span><span class="p">:</span>
        <span class="c1"># Reflection against a fluid-solid interface</span>
        <span class="c1">#   &quot;in&quot; is in the liquid</span>
        <span class="c1">#   &quot;out&quot; is also in the liquid</span>
        <span class="n">solid</span> <span class="o">=</span> <span class="n">material_against</span>
        <span class="n">fluid</span> <span class="o">=</span> <span class="n">material_inc</span>
        <span class="k">assert</span> <span class="n">solid</span><span class="o">.</span><span class="n">state_of_matter</span> <span class="o">==</span> <span class="n">c</span><span class="o">.</span><span class="n">StateMatter</span><span class="o">.</span><span class="n">solid</span>
        <span class="k">assert</span> <span class="n">fluid</span><span class="o">.</span><span class="n">state_of_matter</span> <span class="o">!=</span> <span class="n">c</span><span class="o">.</span><span class="n">StateMatter</span><span class="o">.</span><span class="n">solid</span>

        <span class="n">angles_fluid</span> <span class="o">=</span> <span class="n">angles_inc</span>

        <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">alpha_fluid</span><span class="o">=</span><span class="n">angles_fluid</span><span class="p">,</span>
            <span class="n">alpha_l</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">alpha_t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">rho_fluid</span><span class="o">=</span><span class="n">fluid</span><span class="o">.</span><span class="n">density</span><span class="p">,</span>
            <span class="n">rho_solid</span><span class="o">=</span><span class="n">solid</span><span class="o">.</span><span class="n">density</span><span class="p">,</span>
            <span class="n">c_fluid</span><span class="o">=</span><span class="n">fluid</span><span class="o">.</span><span class="n">longitudinal_vel</span><span class="p">,</span>
            <span class="n">c_l</span><span class="o">=</span><span class="n">solid</span><span class="o">.</span><span class="n">longitudinal_vel</span><span class="p">,</span>
            <span class="n">c_t</span><span class="o">=</span><span class="n">solid</span><span class="o">.</span><span class="n">transverse_vel</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
            <span class="n">reflection</span><span class="p">,</span> <span class="n">transmission_l</span><span class="p">,</span> <span class="n">transmission_t</span> <span class="o">=</span> <span class="n">fluid_solid</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>

        <span class="n">z</span> <span class="o">=</span> <span class="n">material_inc</span><span class="o">.</span><span class="n">velocity</span><span class="p">(</span><span class="n">mode_inc</span><span class="p">)</span> <span class="o">/</span> <span class="n">material_inc</span><span class="o">.</span><span class="n">velocity</span><span class="p">(</span><span class="n">mode_out</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">convert_to_displacement</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">reflection</span> <span class="o">*</span> <span class="n">z</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">reflection</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>



<div class="viewcode-block" id="transmission_reflection_for_path">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.transmission_reflection_for_path.html#arim.model.transmission_reflection_for_path">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">transmission_reflection_for_path</span><span class="p">(</span>
    <span class="n">path</span><span class="p">,</span> <span class="n">ray_geometry</span><span class="p">,</span> <span class="n">force_complex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;stress&quot;</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the transmission-reflection coefficients for a given path.</span>

<span class="sd">    This function takes into account all relevant interfaces defined in ``path``.</span>

<span class="sd">    Requires to have computed the angles of incidence at each interface</span>
<span class="sd">    (cf. :meth:`RayGeometry.conventional_inc_angle`).</span>
<span class="sd">    Use internally :func:`transmission_at_interface`` and :func:``reflection_at_interface``.</span>

<span class="sd">    The angles of transmission or reflection are obtained using Snell-Descartes laws (:func:`snell_angles`).</span>

<span class="sd">    Warning: do not check whether the angles of incidence are physical.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : Path</span>
<span class="sd">    ray_geometry : arim.ray.RayGeometry</span>
<span class="sd">    force_complex : bool</span>
<span class="sd">        If True, return complex coefficients. If not, return coefficients with the same datatype as ``angles_inc``.</span>
<span class="sd">        Default: True.</span>

<span class="sd">    Yields</span>
<span class="sd">    ------</span>
<span class="sd">    amps : ndarray or None</span>
<span class="sd">        Amplitudes of transmission-reflection coefficients. None if not defined for all interface.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [KK]_</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Requires the incoming angles for all interfaces except the probe and the scatterers</span>
    <span class="c1"># (first and last).</span>
    <span class="n">transrefl</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># For all interfaces but the first and last:</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">interface</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">interface</span><span class="o">.</span><span class="n">transmission_reflection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">interface_kind</span><span class="o">=</span><span class="n">interface</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span>
            <span class="n">material_inc</span><span class="o">=</span><span class="n">path</span><span class="o">.</span><span class="n">materials</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">mode_inc</span><span class="o">=</span><span class="n">path</span><span class="o">.</span><span class="n">modes</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">mode_out</span><span class="o">=</span><span class="n">path</span><span class="o">.</span><span class="n">modes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="n">angles_inc</span><span class="o">=</span><span class="n">ray_geometry</span><span class="o">.</span><span class="n">conventional_inc_angle</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
            <span class="n">force_complex</span><span class="o">=</span><span class="n">force_complex</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;compute </span><span class="si">{}</span><span class="s2"> coefficients at interface </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">interface</span><span class="o">.</span><span class="n">transmission_reflection</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">interface</span><span class="o">.</span><span class="n">points</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">interface</span><span class="o">.</span><span class="n">transmission_reflection</span> <span class="ow">is</span> <span class="n">c</span><span class="o">.</span><span class="n">TransmissionReflection</span><span class="o">.</span><span class="n">transmission</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;material_out&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">transmission_at_interface</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">interface</span><span class="o">.</span><span class="n">transmission_reflection</span> <span class="ow">is</span> <span class="n">c</span><span class="o">.</span><span class="n">TransmissionReflection</span><span class="o">.</span><span class="n">reflection</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;material_against&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interface</span><span class="o">.</span><span class="n">reflection_against</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">reflection_at_interface</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span>

        <span class="k">if</span> <span class="n">transrefl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">transrefl</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">transrefl</span> <span class="o">*=</span> <span class="n">tmp</span>
        <span class="k">del</span> <span class="n">tmp</span>

    <span class="k">return</span> <span class="n">transrefl</span></div>



<div class="viewcode-block" id="reverse_transmission_reflection_for_path">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.reverse_transmission_reflection_for_path.html#arim.model.reverse_transmission_reflection_for_path">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">reverse_transmission_reflection_for_path</span><span class="p">(</span>
    <span class="n">path</span><span class="p">,</span> <span class="n">ray_geometry</span><span class="p">,</span> <span class="n">force_complex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;stress&quot;</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the transmission-reflection coefficients of the reverse path.</span>

<span class="sd">    This function uses the same angles as :func:`transmission_reflection_for_path`.</span>
<span class="sd">    These angles are the incident angles in the direct path (but the reflected/transmitted</span>
<span class="sd">    angles in the reverse path).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : Path</span>
<span class="sd">    ray_geometry : arim.ray.RayGeometry</span>
<span class="sd">    force_complex : bool</span>
<span class="sd">        Use complex angles. Default : True</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rev_transrefl : ndarray</span>
<span class="sd">        Shape: (path.interfaces[0].numpoints, path.interfaces[-1].numpoints)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [KK]_</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">transrefl</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># For all interfaces but the first and last:</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">interface</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">interface</span><span class="o">.</span><span class="n">transmission_reflection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">mode_inc</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">modes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">material_inc</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">mode_out</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">modes</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">material_inc</span><span class="o">=</span><span class="n">material_inc</span><span class="p">,</span>
            <span class="n">mode_inc</span><span class="o">=</span><span class="n">mode_inc</span><span class="p">,</span>
            <span class="n">mode_out</span><span class="o">=</span><span class="n">mode_out</span><span class="p">,</span>
            <span class="n">force_complex</span><span class="o">=</span><span class="n">force_complex</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># In the reverse path, transmitted or reflected angles coming out the i-th</span>
        <span class="c1"># interface</span>
        <span class="n">trans_or_refl_angles</span> <span class="o">=</span> <span class="n">ray_geometry</span><span class="o">.</span><span class="n">conventional_inc_angle</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">interface</span><span class="o">.</span><span class="n">transmission_reflection</span> <span class="ow">is</span> <span class="n">c</span><span class="o">.</span><span class="n">TransmissionReflection</span><span class="o">.</span><span class="n">transmission</span><span class="p">:</span>
            <span class="n">material_out</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">materials</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;material_out&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">material_out</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;interface_kind&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interface</span><span class="o">.</span><span class="n">kind</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

            <span class="c1"># Compute the incident angles in the reverse path from the incident angles in the</span>
            <span class="c1"># direct path using Snell laws.</span>
            <span class="k">if</span> <span class="n">force_complex</span><span class="p">:</span>
                <span class="n">trans_or_refl_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">trans_or_refl_angles</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;angles_inc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">snell_angles</span><span class="p">(</span>
                <span class="n">trans_or_refl_angles</span><span class="p">,</span>
                <span class="n">material_out</span><span class="o">.</span><span class="n">velocity</span><span class="p">(</span><span class="n">mode_out</span><span class="p">),</span>
                <span class="n">material_inc</span><span class="o">.</span><span class="n">velocity</span><span class="p">(</span><span class="n">mode_inc</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">transmission_at_interface</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">interface</span><span class="o">.</span><span class="n">transmission_reflection</span> <span class="ow">is</span> <span class="n">c</span><span class="o">.</span><span class="n">TransmissionReflection</span><span class="o">.</span><span class="n">reflection</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;material_against&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interface</span><span class="o">.</span><span class="n">reflection_against</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;interface_kind&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interface</span><span class="o">.</span><span class="n">kind</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;angles_inc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">snell_angles</span><span class="p">(</span>
                <span class="n">trans_or_refl_angles</span><span class="p">,</span>
                <span class="n">material_inc</span><span class="o">.</span><span class="n">velocity</span><span class="p">(</span><span class="n">mode_out</span><span class="p">),</span>
                <span class="n">material_inc</span><span class="o">.</span><span class="n">velocity</span><span class="p">(</span><span class="n">mode_inc</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">reflection_at_interface</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span>

        <span class="k">if</span> <span class="n">transrefl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">transrefl</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">transrefl</span> <span class="o">*=</span> <span class="n">tmp</span>
        <span class="k">del</span> <span class="n">tmp</span>

    <span class="k">return</span> <span class="n">transrefl</span></div>



<div class="viewcode-block" id="beamspread_2d_for_path">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.beamspread_2d_for_path.html#arim.model.beamspread_2d_for_path">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">beamspread_2d_for_path</span><span class="p">(</span><span class="n">ray_geometry</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the 2D beamspread for a path. This function supports rays which goes through</span>
<span class="sd">    several interfaces (with virtual source).</span>

<span class="sd">    Only the (conventional) incoming angles are used, it is assumed in that the outgoing</span>
<span class="sd">    angles follow Snell laws.</span>

<span class="sd">    The beamspread has the dimension of 1/sqrt(r).</span>

<span class="sd">    In an unbounded medium::</span>

<span class="sd">        beamspread := 1/sqrt(r)</span>

<span class="sd">    Through one interface::</span>

<span class="sd">        beamspread := 1/sqrt(r1 + r2/beta)</span>

<span class="sd">    where::</span>

<span class="sd">        beta := (c1 * cos(theta2)^2) / (c2 * cos(theta1)^2)</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ray_geometry : arim.ray.RayGeometry</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    beamspread : ndarray</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [SchmerrArrays]_, §2.5</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">velocities</span> <span class="o">=</span> <span class="n">ray_geometry</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">fermat_path</span><span class="o">.</span><span class="n">velocities</span>

    <span class="c1"># Using notations from forward model, this function computes the beamspread at A_n</span>
    <span class="c1"># where n = ray_geometry.numinterfaces - 1</span>
    <span class="c1"># Case n=0: undefined</span>
    <span class="c1"># Case n=1: beamspread = 1/sqrt(r)</span>

    <span class="c1"># Precompute gamma (coefficient of conversion between actual source</span>
    <span class="c1"># and virtual source)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">ray_geometry</span><span class="o">.</span><span class="n">numinterfaces</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">gamma_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="c1"># k varies in [1, n-1] (included)</span>
        <span class="n">theta_inc</span> <span class="o">=</span> <span class="n">ray_geometry</span><span class="o">.</span><span class="n">conventional_inc_angle</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="n">nu</span> <span class="o">=</span> <span class="n">velocities</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">velocities</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">sin_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_inc</span><span class="p">)</span>
        <span class="n">cos_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta_inc</span><span class="p">)</span>
        <span class="n">gamma_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">(</span><span class="n">nu</span> <span class="o">*</span> <span class="n">nu</span> <span class="o">-</span> <span class="n">sin_theta</span> <span class="o">*</span> <span class="n">sin_theta</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nu</span> <span class="o">*</span> <span class="n">cos_theta</span> <span class="o">*</span> <span class="n">cos_theta</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Between the probe and the first interface, beamspread of an unbounded medium.</span>
    <span class="c1"># Use a copy because the original may be a cached value and we don&#39;ray want</span>
    <span class="c1"># to change it by accident.</span>
    <span class="n">virtual_distance</span> <span class="o">=</span> <span class="n">ray_geometry</span><span class="o">.</span><span class="n">inc_leg_size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># distance A_0 A_1</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="c1"># distance A_k A_{k+1}:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">ray_geometry</span><span class="o">.</span><span class="n">inc_leg_size</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">gamma</span> <span class="o">*=</span> <span class="n">gamma_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">virtual_distance</span> <span class="o">+=</span> <span class="n">r</span> <span class="o">/</span> <span class="n">gamma</span>
    <span class="c1"># Note: beyond the critical angle, virtual ditance is often -ve, leading to nan</span>
    <span class="c1"># values in resulting sensitivity. Use this to set to zero instead of nan.</span>
    <span class="n">virtual_distance</span><span class="p">[</span><span class="n">virtual_distance</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reciprocal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">virtual_distance</span><span class="p">))</span></div>



<div class="viewcode-block" id="reverse_beamspread_2d_for_path">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.reverse_beamspread_2d_for_path.html#arim.model.reverse_beamspread_2d_for_path">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">reverse_beamspread_2d_for_path</span><span class="p">(</span><span class="n">ray_geometry</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reverse beamspread for a path.</span>
<span class="sd">    Uses the same angles as in beamspread_2d_for_path for consistency.</span>

<span class="sd">    For a ray (i, ..., j), the reverse beamspread is obtained by considering the point</span>
<span class="sd">    j is the source and i is the endpoint. The direct beamspread considers this is the</span>
<span class="sd">    opposite.</span>

<span class="sd">    This gives the same result as beamspread_2d_for_path(reversed_ray_geometry)</span>
<span class="sd">    assuming the rays perfectly follow Snell laws. Because of errors in the ray tracing,</span>
<span class="sd">    there is a small difference.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ray_geometry : arim.ray.RayGeometry</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rev_beamspread : ndarray</span>
<span class="sd">        Shape: (numelements, numgridpoints)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">velocities</span> <span class="o">=</span> <span class="n">ray_geometry</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">fermat_path</span><span class="o">.</span><span class="n">velocities</span>
    <span class="c1"># import pdb; pdb.set_trace()</span>

    <span class="c1"># Using notations from forward model, this function computes the beamspread at A_n</span>
    <span class="c1"># where n = ray_geometry.numinterfaces - 1</span>
    <span class="c1"># Case n=0: undefined</span>
    <span class="c1"># Case n=1: beamspread = 1/sqrt(r)</span>

    <span class="c1"># Precompute gamma (coefficient of conversion between actual source</span>
    <span class="c1"># and virtual source)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">ray_geometry</span><span class="o">.</span><span class="n">numinterfaces</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">gamma_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="c1"># k varies in [1, n-1] (included)</span>
        <span class="n">theta_out</span> <span class="o">=</span> <span class="n">ray_geometry</span><span class="o">.</span><span class="n">conventional_inc_angle</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">velocities</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">velocities</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">sin_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_out</span><span class="p">)</span>
        <span class="n">cos_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta_out</span><span class="p">)</span>
        <span class="c1"># gamma expressed with theta_out instead of theta_in</span>
        <span class="n">gamma_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">(</span><span class="n">nu</span> <span class="o">*</span> <span class="n">cos_theta</span> <span class="o">*</span> <span class="n">cos_theta</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">nu</span> <span class="o">*</span> <span class="n">nu</span> <span class="o">*</span> <span class="n">sin_theta</span> <span class="o">*</span> <span class="n">sin_theta</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Between the probe and the first interface, beamspread of an unbounded medium.</span>
    <span class="c1"># Use a copy because the original may be a cached value and we don&#39;ray want</span>
    <span class="c1"># to change it by accident.</span>
    <span class="n">virtual_distance</span> <span class="o">=</span> <span class="n">ray_geometry</span><span class="o">.</span><span class="n">inc_leg_size</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="c1"># distance A_k A_{k+1}:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">ray_geometry</span><span class="o">.</span><span class="n">inc_leg_size</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">gamma</span> <span class="o">*=</span> <span class="n">gamma_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">virtual_distance</span> <span class="o">+=</span> <span class="n">r</span> <span class="o">/</span> <span class="n">gamma</span>

    <span class="c1"># See `beamspread_2d_for_path()` about the need for this.</span>
    <span class="n">virtual_distance</span><span class="p">[</span><span class="n">virtual_distance</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reciprocal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">virtual_distance</span><span class="p">))</span></div>



<div class="viewcode-block" id="material_attenuation_for_path">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.material_attenuation_for_path.html#arim.model.material_attenuation_for_path">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">material_attenuation_for_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ray_geometry</span><span class="p">,</span> <span class="n">frequency</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return material attenuation for each ray (between 0 and 1)</span>

<span class="sd">    .. math::</span>

<span class="sd">        M(\omega) = \exp(- \sum_i a_i(\omega) d_i)</span>

<span class="sd">    If no attenuation is provided, ignore silently.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : Path</span>
<span class="sd">    ray_geometry : arim.ray.RayGeometry</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    attenuation : ndarray</span>
<span class="sd">        Shape: (numelements, numgridpoints)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [Schmerr]_ chapter 9</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">log_att</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">numpoints</span><span class="p">,</span> <span class="n">path</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">numpoints</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">material</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">materials</span><span class="p">,</span> <span class="n">path</span><span class="o">.</span><span class="n">modes</span><span class="p">),</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">att_obj</span> <span class="o">=</span> <span class="n">material</span><span class="o">.</span><span class="n">attenuation</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">att_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">att_coeff</span> <span class="o">=</span> <span class="n">att_obj</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span>
            <span class="n">log_att</span> <span class="o">-=</span> <span class="n">att_coeff</span> <span class="o">*</span> <span class="n">ray_geometry</span><span class="o">.</span><span class="n">inc_leg_size</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_att</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_nested_dict_to_flat_list</span><span class="p">(</span><span class="n">dictlike</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">dictlike</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">dictlike</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># dictlike is a leaf:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">dictlike</span><span class="p">]</span>
        <span class="c1"># dictlike is not a leaf:</span>
        <span class="n">all_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="c1"># union of sets:</span>
            <span class="n">all_values</span> <span class="o">=</span> <span class="n">_nested_dict_to_flat_list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">all_values</span>


<div class="viewcode-block" id="RayWeights">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.RayWeights.html#arim.model.RayWeights">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RayWeights</span><span class="p">(</span>
    <span class="n">namedtuple</span><span class="p">(</span>
        <span class="s2">&quot;RayWeights&quot;</span><span class="p">,</span>
        <span class="p">[</span>
            <span class="s2">&quot;tx_ray_weights_dict&quot;</span><span class="p">,</span>
            <span class="s2">&quot;rx_ray_weights_dict&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tx_ray_weights_debug_dict&quot;</span><span class="p">,</span>
            <span class="s2">&quot;rx_ray_weights_debug_dict&quot;</span><span class="p">,</span>
            <span class="s2">&quot;scattering_angles_dict&quot;</span><span class="p">,</span>
        <span class="p">],</span>
    <span class="p">)</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Data container for ray weights.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    tx_ray_weights_dict : dict[arim.Path, ndarray]</span>
<span class="sd">        Each value has a shape of (numelements, numgridpoints)</span>
<span class="sd">    rx_ray_weights_dict : dict[arim.Path, ndarray]</span>
<span class="sd">        Each value has a shape of (numelements, numgridpoints)</span>
<span class="sd">    tx_ray_weights_debug_dict : dict</span>
<span class="sd">        See function tx_ray_weights</span>
<span class="sd">    rx_ray_weights_debug_dict : dict</span>
<span class="sd">        See function rx_ray_weights</span>
<span class="sd">    scattering_angles_dict : dict[arim.Path, ndarray]</span>
<span class="sd">        Each value has a shape of (numelements, numgridpoints)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">all_arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">all_arrays</span> <span class="o">+=</span> <span class="n">_nested_dict_to_flat_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tx_ray_weights_dict</span><span class="p">)</span>
        <span class="n">all_arrays</span> <span class="o">+=</span> <span class="n">_nested_dict_to_flat_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rx_ray_weights_dict</span><span class="p">)</span>
        <span class="n">all_arrays</span> <span class="o">+=</span> <span class="n">_nested_dict_to_flat_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tx_ray_weights_debug_dict</span><span class="p">)</span>
        <span class="n">all_arrays</span> <span class="o">+=</span> <span class="n">_nested_dict_to_flat_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rx_ray_weights_debug_dict</span><span class="p">)</span>
        <span class="n">all_arrays</span> <span class="o">+=</span> <span class="n">_nested_dict_to_flat_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scattering_angles_dict</span><span class="p">)</span>
        <span class="c1"># an array is not hashable so we cheat a bit to get unique arrays</span>
        <span class="n">unique_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">all_arrays</span><span class="p">)</span>
        <span class="n">nbytes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">all_arrays</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="ow">in</span> <span class="n">unique_ids</span><span class="p">:</span>
                <span class="n">nbytes</span> <span class="o">+=</span> <span class="n">arr</span><span class="o">.</span><span class="n">nbytes</span>
                <span class="n">unique_ids</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">nbytes</span></div>



<div class="viewcode-block" id="model_amplitudes_factory">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.model_amplitudes_factory.html#arim.model.model_amplitudes_factory">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">model_amplitudes_factory</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">ray_weights</span><span class="p">,</span> <span class="n">scattering</span><span class="p">,</span> <span class="n">scat_angle</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the model coefficients once the ray weights are known.</span>

<span class="sd">    The effective scattering is ``scattering(inc_theta - scat_angle, out_theta - scat_angle)``</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tx : ndarray</span>
<span class="sd">    rx : ndarray</span>
<span class="sd">    view : View</span>
<span class="sd">    ray_weights : RayWeights</span>
<span class="sd">    scattering : dict</span>
<span class="sd">        Dict of functions (slow but precise) or matrices(fast but precision depends on</span>
<span class="sd">        the angle sampling).</span>
<span class="sd">    scat_angle : float</span>

<span class="sd">    Returns</span>
<span class="sd">    ------</span>
<span class="sd">    model_amplitudes : ModelAmplitudes</span>
<span class="sd">        Object that is indexable with a grid point index or a slice of grid points. The</span>
<span class="sd">         values are computed on the fly.</span>

<span class="sd">        can be indexe as an array but that computes the</span>
<span class="sd">        Function that returns the model amplitudes and takes as argument a slice.</span>
<span class="sd">        ndarray</span>
<span class="sd">        Shape: (blocksize, numtimetraces)</span>
<span class="sd">        Yield until all grid points are processed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; model_amplitudes = model_amplitudes_factory(tx, rx, view, ray_weights, scattering)</span>
<span class="sd">    &gt;&gt;&gt; model_amplitudes[0]</span>
<span class="sd">    # returns the &#39;numtimetraces&#39; amplitudes at the grid point 0</span>

<span class="sd">    &gt;&gt;&gt; model_amplitudes[:10] # returns the amplitudes for the first 10 grid points</span>
<span class="sd">    array([ 0.27764253,  0.78863332,  0.83998295,  0.96811351,  0.57929045, 0.00935137,  0.8905348 ,  0.46976061,  0.08101099,  0.57615469])</span>

<span class="sd">    &gt;&gt;&gt; model_amplitudes[...] # returns the amplitudes for all points. Warning: you may</span>
<span class="sd">    ... # run out of memory!</span>
<span class="sd">    array([...])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Pick the right scattering matrix/function.</span>
    <span class="c1"># scat_key is LL, LT, TL or TT</span>
    <span class="n">scattering_obj</span> <span class="o">=</span> <span class="n">scattering</span><span class="p">[</span><span class="n">view</span><span class="o">.</span><span class="n">scat_key</span><span class="p">()]</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">scattering_obj</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">is_scattering_func</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">is_scattering_func</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">tx_ray_weights</span> <span class="o">=</span> <span class="n">ray_weights</span><span class="o">.</span><span class="n">tx_ray_weights_dict</span><span class="p">[</span><span class="n">view</span><span class="o">.</span><span class="n">tx_path</span><span class="p">]</span>
    <span class="n">rx_ray_weights</span> <span class="o">=</span> <span class="n">ray_weights</span><span class="o">.</span><span class="n">rx_ray_weights_dict</span><span class="p">[</span><span class="n">view</span><span class="o">.</span><span class="n">rx_path</span><span class="p">]</span>
    <span class="n">tx_scattering_angles</span> <span class="o">=</span> <span class="n">ray_weights</span><span class="o">.</span><span class="n">scattering_angles_dict</span><span class="p">[</span><span class="n">view</span><span class="o">.</span><span class="n">tx_path</span><span class="p">]</span>
    <span class="n">rx_scattering_angles</span> <span class="o">=</span> <span class="n">ray_weights</span><span class="o">.</span><span class="n">scattering_angles_dict</span><span class="p">[</span><span class="n">view</span><span class="o">.</span><span class="n">rx_path</span><span class="p">]</span>

    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">tx_ray_weights</span><span class="o">.</span><span class="n">shape</span>
        <span class="o">==</span> <span class="n">rx_ray_weights</span><span class="o">.</span><span class="n">shape</span>
        <span class="o">==</span> <span class="n">tx_scattering_angles</span><span class="o">.</span><span class="n">shape</span>
        <span class="o">==</span> <span class="n">rx_scattering_angles</span><span class="o">.</span><span class="n">shape</span>
    <span class="p">)</span>

    <span class="c1"># the great transposition</span>
    <span class="n">tx_ray_weights</span> <span class="o">=</span> <span class="n">tx_ray_weights</span><span class="o">.</span><span class="n">T</span>
    <span class="n">rx_ray_weights</span> <span class="o">=</span> <span class="n">rx_ray_weights</span><span class="o">.</span><span class="n">T</span>
    <span class="n">tx_scattering_angles</span> <span class="o">=</span> <span class="n">tx_scattering_angles</span><span class="o">.</span><span class="n">T</span>
    <span class="n">rx_scattering_angles</span> <span class="o">=</span> <span class="n">rx_scattering_angles</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="n">is_scattering_func</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_ModelAmplitudesWithScatFunction</span><span class="p">(</span>
            <span class="n">tx</span><span class="p">,</span>
            <span class="n">rx</span><span class="p">,</span>
            <span class="n">scattering_obj</span><span class="p">,</span>
            <span class="n">tx_ray_weights</span><span class="p">,</span>
            <span class="n">rx_ray_weights</span><span class="p">,</span>
            <span class="n">tx_scattering_angles</span><span class="p">,</span>
            <span class="n">rx_scattering_angles</span><span class="p">,</span>
            <span class="n">scat_angle</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_ModelAmplitudesWithScatMatrix</span><span class="p">(</span>
            <span class="n">tx</span><span class="p">,</span>
            <span class="n">rx</span><span class="p">,</span>
            <span class="n">scattering_obj</span><span class="p">,</span>
            <span class="n">tx_ray_weights</span><span class="p">,</span>
            <span class="n">rx_ray_weights</span><span class="p">,</span>
            <span class="n">tx_scattering_angles</span><span class="p">,</span>
            <span class="n">rx_scattering_angles</span><span class="p">,</span>
            <span class="n">scat_angle</span><span class="p">,</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="ModelAmplitudes">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.ModelAmplitudes.html#arim.model.ModelAmplitudes">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ModelAmplitudes</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for on-the-fly calculation of model amplitudes.</span>


<span class="sd">    Pseudo-array of coefficients P_ij = Q_i Q&#39;_j S_ij. Shape: (numpoints, numtimetraces)</span>

<span class="sd">    This object can be indexed almost like a regular Numpy array.</span>
<span class="sd">    When indexed, the values are computed on the fly.</span>
<span class="sd">    Otherwise an array of this size would be too large.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Only the first dimension must be indexed. See examples below.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; model_amplitudes = model_amplitudes_factory(tx, rx, view, ray_weights, scattering_dict)</span>

<span class="sd">    This object is not an array:</span>

<span class="sd">    &gt;&gt;&gt; type(model_amplitudes)</span>
<span class="sd">    __main__.ModelAmplitudes</span>

<span class="sd">    But when indexed, it returns an array:</span>

<span class="sd">    &gt;&gt;&gt; type(model_amplitudes[0])</span>
<span class="sd">    numpy.ndarray</span>

<span class="sd">    Get the P_ij for the first grid point (returns an array of size (numtimetraces,)):</span>

<span class="sd">    &gt;&gt;&gt; model_amplitudes[0]</span>

<span class="sd">    Get the P_ij for the first ten grid points (returns an array of size</span>
<span class="sd">    (10, numtimetraces,)):</span>

<span class="sd">    &gt;&gt;&gt; model_amplitudes[:10]</span>

<span class="sd">    Get all P_ij (may run out of memory):</span>

<span class="sd">    &gt;&gt;&gt; model_amplitudes[...]</span>

<span class="sd">    To get the first Get all P_ij (may run out of memory):</span>

<span class="sd">    &gt;&gt;&gt; model_amplitudes[...]</span>

<span class="sd">    Indexing the second dimension will fail. For example to model amplitude of</span>
<span class="sd">    the fourth point and the eigth timetrace, use:</span>

<span class="sd">    &gt;&gt;&gt; model_amplitudes[3][7]  # valid usage</span>
<span class="sd">    &gt;&gt;&gt; model_amplitudes[3, 7]  # invalid usage, raise an IndexError</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_slice</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numpoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numtimetraces</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

<div class="viewcode-block" id="ModelAmplitudes.sensitivity_uniform_tfm">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.ModelAmplitudes.html#arim.model.ModelAmplitudes.sensitivity_uniform_tfm">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sensitivity_uniform_tfm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timetrace_weights</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># wrapper in general case, inherit and write a faster implementation if possible</span>
        <span class="k">return</span> <span class="n">sensitivity_uniform_tfm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timetrace_weights</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="ModelAmplitudes.sensitivity_model_assisted_tfm">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.ModelAmplitudes.html#arim.model.ModelAmplitudes.sensitivity_model_assisted_tfm">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sensitivity_model_assisted_tfm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timetrace_weights</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># wrapper in general case, inherit and write a faster implementation if possible</span>
        <span class="k">return</span> <span class="n">sensitivity_model_assisted_tfm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timetrace_weights</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="ModelAmplitudes.to_matched_filter_amplitudes">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.ModelAmplitudes.html#arim.model.ModelAmplitudes.to_matched_filter_amplitudes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_matched_filter_amplitudes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_slice</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare model amplitudes for use as a matched filter weighting in TFM function</span>
<span class="sd">        as amplitudes [Turin]_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">grid_slice</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">grid_slice</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="n">grid_slice</span><span class="p">])</span></div>
</div>



<span class="k">class</span><span class="w"> </span><span class="nc">_ModelAmplitudesWithScatFunction</span><span class="p">(</span><span class="n">ModelAmplitudes</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tx</span><span class="p">,</span>
        <span class="n">rx</span><span class="p">,</span>
        <span class="n">scattering_fn</span><span class="p">,</span>
        <span class="n">tx_ray_weights</span><span class="p">,</span>
        <span class="n">rx_ray_weights</span><span class="p">,</span>
        <span class="n">tx_scattering_angles</span><span class="p">,</span>
        <span class="n">rx_scattering_angles</span><span class="p">,</span>
        <span class="n">scat_angle</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tx</span> <span class="o">=</span> <span class="n">tx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rx</span> <span class="o">=</span> <span class="n">rx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scattering_fn</span> <span class="o">=</span> <span class="n">scattering_fn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tx_ray_weights</span> <span class="o">=</span> <span class="n">tx_ray_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rx_ray_weights</span> <span class="o">=</span> <span class="n">rx_ray_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tx_scattering_angles</span> <span class="o">=</span> <span class="n">tx_scattering_angles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rx_scattering_angles</span> <span class="o">=</span> <span class="n">rx_scattering_angles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numpoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numelements</span> <span class="o">=</span> <span class="n">tx_ray_weights</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numtimetraces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scat_angle</span> <span class="o">=</span> <span class="n">scat_angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="nb">complex</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_slice</span><span class="p">):</span>
        <span class="c1"># Nota bene: arrays&#39; shape is (numpoints, numtimetrace), i.e. the transpose</span>
        <span class="c1"># of RayWeights. They are contiguous.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numpoints</span><span class="p">)[</span><span class="n">grid_slice</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Only the first dimension of the object is indexable.&quot;</span><span class="p">)</span>

        <span class="n">scat_angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scat_angle</span>
        <span class="n">scattering_amplitudes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scattering_fn</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tx_scattering_angles</span><span class="p">[</span><span class="n">grid_slice</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">scat_angle</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rx_scattering_angles</span><span class="p">[</span><span class="n">grid_slice</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">scat_angle</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">model_amplitudes</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">scattering_amplitudes</span>
            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tx_ray_weights</span><span class="p">[</span><span class="n">grid_slice</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rx_ray_weights</span><span class="p">[</span><span class="n">grid_slice</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">model_amplitudes</span>


<span class="nd">@numba</span><span class="o">.</span><span class="n">guvectorize</span><span class="p">(</span>
    <span class="s2">&quot;void(int_[:], int_[:], complex128[:,:], complex128[:], complex128[:], float64[:], float64[:], float64[:], complex128[:])&quot;</span><span class="p">,</span>
    <span class="s2">&quot;(n),(n),(s,s),(e),(e),(e),(e),()-&gt;(n)&quot;</span><span class="p">,</span>
    <span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">target</span><span class="o">=</span><span class="s2">&quot;parallel&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_model_amplitudes_with_scat_matrix</span><span class="p">(</span>
    <span class="n">tx</span><span class="p">,</span>
    <span class="n">rx</span><span class="p">,</span>
    <span class="n">scattering_matrix</span><span class="p">,</span>
    <span class="n">tx_ray_weights</span><span class="p">,</span>
    <span class="n">rx_ray_weights</span><span class="p">,</span>
    <span class="n">tx_scattering_angles</span><span class="p">,</span>
    <span class="n">rx_scattering_angles</span><span class="p">,</span>
    <span class="n">scat_angle</span><span class="p">,</span>
    <span class="n">res</span><span class="p">,</span>
<span class="p">):</span>
    <span class="c1"># This is a kernel on a grid point.</span>
    <span class="n">numtimetraces</span> <span class="o">=</span> <span class="n">tx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># assert res.shape[0] == tx_ray_weights.shape[0]</span>
    <span class="c1"># assert tx_ray_weights.shape == rx_ray_weights.shape == tx_scattering_angles.shape == rx_scattering_angles.shape</span>
    <span class="k">for</span> <span class="n">scan</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numtimetraces</span><span class="p">):</span>
        <span class="n">inc_theta</span> <span class="o">=</span> <span class="n">tx_scattering_angles</span><span class="p">[</span><span class="n">tx</span><span class="p">[</span><span class="n">scan</span><span class="p">]]</span> <span class="o">-</span> <span class="n">scat_angle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">out_theta</span> <span class="o">=</span> <span class="n">rx_scattering_angles</span><span class="p">[</span><span class="n">rx</span><span class="p">[</span><span class="n">scan</span><span class="p">]]</span> <span class="o">-</span> <span class="n">scat_angle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">scattering_amp</span> <span class="o">=</span> <span class="n">_scat</span><span class="o">.</span><span class="n">_interpolate_scattering_matrix_kernel</span><span class="p">(</span>
            <span class="n">scattering_matrix</span><span class="p">,</span> <span class="n">inc_theta</span><span class="p">,</span> <span class="n">out_theta</span>
        <span class="p">)</span>
        <span class="n">res</span><span class="p">[</span><span class="n">scan</span><span class="p">]</span> <span class="o">=</span> <span class="n">scattering_amp</span> <span class="o">*</span> <span class="n">tx_ray_weights</span><span class="p">[</span><span class="n">tx</span><span class="p">[</span><span class="n">scan</span><span class="p">]]</span> <span class="o">*</span> <span class="n">rx_ray_weights</span><span class="p">[</span><span class="n">rx</span><span class="p">[</span><span class="n">scan</span><span class="p">]]</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_ModelAmplitudesWithScatMatrix</span><span class="p">(</span><span class="n">ModelAmplitudes</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tx</span><span class="p">,</span>
        <span class="n">rx</span><span class="p">,</span>
        <span class="n">scattering_mat</span><span class="p">,</span>
        <span class="n">tx_ray_weights</span><span class="p">,</span>
        <span class="n">rx_ray_weights</span><span class="p">,</span>
        <span class="n">tx_scattering_angles</span><span class="p">,</span>
        <span class="n">rx_scattering_angles</span><span class="p">,</span>
        <span class="n">scat_angle</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tx</span> <span class="o">=</span> <span class="n">tx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rx</span> <span class="o">=</span> <span class="n">rx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scattering_mat</span> <span class="o">=</span> <span class="n">scattering_mat</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tx_ray_weights</span> <span class="o">=</span> <span class="n">tx_ray_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rx_ray_weights</span> <span class="o">=</span> <span class="n">rx_ray_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tx_scattering_angles</span> <span class="o">=</span> <span class="n">tx_scattering_angles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rx_scattering_angles</span> <span class="o">=</span> <span class="n">rx_scattering_angles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numpoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numelements</span> <span class="o">=</span> <span class="n">tx_ray_weights</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numtimetraces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scat_angle</span> <span class="o">=</span> <span class="n">scat_angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">tx_ray_weights</span><span class="p">,</span> <span class="n">rx_ray_weights</span><span class="p">,</span> <span class="n">scattering_mat</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_slice</span><span class="p">):</span>
        <span class="c1"># Nota bene: arrays&#39; shape is (numpoints, numtimetrace), i.e. the transpose</span>
        <span class="c1"># of RayWeights. They are contiguous.</span>
        <span class="k">return</span> <span class="n">_model_amplitudes_with_scat_matrix</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tx</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rx</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scattering_mat</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tx_ray_weights</span><span class="p">[</span><span class="n">grid_slice</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rx_ray_weights</span><span class="p">[</span><span class="n">grid_slice</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tx_scattering_angles</span><span class="p">[</span><span class="n">grid_slice</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rx_scattering_angles</span><span class="p">[</span><span class="n">grid_slice</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scat_angle</span><span class="p">,</span>
        <span class="p">)</span>


<div class="viewcode-block" id="sensitivity_uniform_tfm">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.sensitivity_uniform_tfm.html#arim.model.sensitivity_uniform_tfm">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sensitivity_uniform_tfm</span><span class="p">(</span><span class="n">model_amplitudes</span><span class="p">,</span> <span class="n">timetrace_weights</span><span class="p">,</span> <span class="n">block_size</span><span class="o">=</span><span class="mi">4000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the sensitivity for uniform TFM.</span>

<span class="sd">    The sensitivity at a point is defined the predicted TFM amplitude that a sole</span>
<span class="sd">    scatterer centered on that point would have.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model_amplitudes : ndarray or ModelAmplitudes</span>
<span class="sd">        Coefficients P_ij. Shape: (numpoints, numtimetraces)</span>
<span class="sd">    timetrace_weights : ndarray</span>
<span class="sd">        Shape: (numtimetraces, )</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    predicted_intensities</span>
<span class="sd">        Shape: (numpoints, )</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">numpoints</span><span class="p">,</span> <span class="n">numtimetraces</span> <span class="o">=</span> <span class="n">model_amplitudes</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">timetrace_weights</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">model_amplitudes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">timetrace_weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">sensitivity</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># chunk the array in case we have an array too big (ModelAmplitudes)</span>
    <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">helpers</span><span class="o">.</span><span class="n">chunk_array</span><span class="p">((</span><span class="n">numpoints</span><span class="p">,</span> <span class="n">numtimetraces</span><span class="p">),</span> <span class="n">block_size</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">timetrace_weights</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">model_amplitudes</span><span class="p">[</span><span class="n">chunk</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sensitivity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sensitivity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numpoints</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tmp</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">sensitivity</span><span class="p">[</span><span class="n">chunk</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
    <span class="n">sensitivity</span> <span class="o">/=</span> <span class="n">numtimetraces</span>
    <span class="k">return</span> <span class="n">sensitivity</span></div>



<div class="viewcode-block" id="sensitivity_model_assisted_tfm">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.sensitivity_model_assisted_tfm.html#arim.model.sensitivity_model_assisted_tfm">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sensitivity_model_assisted_tfm</span><span class="p">(</span>
    <span class="n">model_amplitudes</span><span class="p">,</span> <span class="n">timetrace_weights</span><span class="p">,</span> <span class="n">block_size</span><span class="o">=</span><span class="mi">4000</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the sensitivity for model assisted TFM (multiply TFM timetraces by conjugate</span>
<span class="sd">    of scatterer contribution).</span>

<span class="sd">    The sensitivity at a point is defined the predicted TFM amplitude that a sole</span>
<span class="sd">    scatterer centered on that point would have.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model_amplitudes : ndarray or ModelAmplitudes</span>
<span class="sd">        Coefficients P_ij. Shape: (numpoints, numtimetraces)</span>
<span class="sd">    timetrace_weights : ndarray</span>
<span class="sd">        Shape: (numtimetraces, )</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    predicted_intensities</span>
<span class="sd">        Shape: (numpoints, ).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">numpoints</span><span class="p">,</span> <span class="n">numtimetraces</span> <span class="o">=</span> <span class="n">model_amplitudes</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">timetrace_weights</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">model_amplitudes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">timetrace_weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">sensitivity</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># chunk the array in case we have an array too big (ModelAmplitudes)</span>
    <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">helpers</span><span class="o">.</span><span class="n">chunk_array</span><span class="p">((</span><span class="n">numpoints</span><span class="p">,</span> <span class="n">numtimetraces</span><span class="p">),</span> <span class="n">block_size</span><span class="p">):</span>
        <span class="n">absval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">model_amplitudes</span><span class="p">[</span><span class="n">chunk</span><span class="p">])</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">absval</span> <span class="o">*</span> <span class="n">absval</span> <span class="o">*</span> <span class="n">timetrace_weights</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sensitivity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sensitivity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numpoints</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tmp</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">sensitivity</span><span class="p">[</span><span class="n">chunk</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
    <span class="n">sensitivity</span> <span class="o">/=</span> <span class="n">numtimetraces</span>
    <span class="k">return</span> <span class="n">sensitivity</span></div>



<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="n">use_parallel</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_timeshift_timedomain</span><span class="p">(</span><span class="n">unshifted_response</span><span class="p">,</span> <span class="n">delays</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">t0_idx</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">unshifted_response</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">numba</span><span class="o">.</span><span class="n">prange</span><span class="p">(</span><span class="n">unshifted_response</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">delay_idx</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">delays</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">delay_idx</span> <span class="o">-</span> <span class="n">t0_idx</span> <span class="p">:</span> <span class="n">delay_idx</span> <span class="o">-</span> <span class="n">t0_idx</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="n">unshifted_response</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>


<div class="viewcode-block" id="transfer_func_to_timetraces">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.transfer_func_to_timetraces.html#arim.model.transfer_func_to_timetraces">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">transfer_func_to_timetraces</span><span class="p">(</span>
    <span class="n">unshifted_transfer_func</span><span class="p">,</span>
    <span class="n">delays</span><span class="p">,</span>
    <span class="n">timetraces_time</span><span class="p">,</span>
    <span class="n">toneburst_time</span><span class="p">,</span>
    <span class="n">toneburst_freq</span><span class="p">,</span>
    <span class="n">toneburst_f</span><span class="p">,</span>
    <span class="n">toneburst_t0_idx</span><span class="p">,</span>
    <span class="n">timetraces</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns time-domain timetraces from the unshifted transfer function and the toneburst</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unshifted_transfer_func : ndarray</span>
<span class="sd">        Transfer function to apply, without the &quot;exp(-i omega tau)&quot; term.</span>
<span class="sd">        Shape ``(numtimetraces, numfreq)`` or ``(numscatterers, numtimetraces, numfreq)``</span>
<span class="sd">    delays : ndarray</span>
<span class="sd">        Delay for each scatterer and timetrace.</span>
<span class="sd">        Shape ``(numtimetraces,)`` or ``(numscatterers, numtimetraces)``</span>
<span class="sd">    timetraces_time : arim.core.Time</span>
<span class="sd">    toneburst_time : arim.core.Time</span>
<span class="sd">    toneburst_freq : ndarray</span>
<span class="sd">        Frequency array of the toneburst, obtained typically with ``np.fft.rfftfreq``</span>
<span class="sd">    toneburst_f : ndarray</span>
<span class="sd">        Spectrum of the toneburst, obtained with ``np.fft.rfft``.</span>
<span class="sd">    toneburst_t0_idx : [type]</span>
<span class="sd">        Index so that ``toneburst_time.samples[t0_idx] = 0.``</span>
<span class="sd">    timetraces : ndarray</span>
<span class="sd">        Optional, write on this array if provided.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    timetraces : ndarray</span>
<span class="sd">        timetraces</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">unshifted_transfer_func</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">unshifted_transfer_func</span> <span class="o">=</span> <span class="n">unshifted_transfer_func</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">unshifted_transfer_func</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">delays</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">delays</span> <span class="o">=</span> <span class="n">delays</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">delays</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">numscatterers</span><span class="p">,</span> <span class="n">numtimetraces</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">unshifted_transfer_func</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">delays</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">numscatterers</span><span class="p">,</span> <span class="n">numtimetraces</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">timetraces_time</span><span class="o">.</span><span class="n">step</span> <span class="o">!=</span> <span class="n">toneburst_time</span><span class="o">.</span><span class="n">step</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">timetraces_time</span><span class="o">.</span><span class="n">step</span>

    <span class="k">if</span> <span class="n">timetraces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">timetraces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numtimetraces</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">timetraces_time</span><span class="p">)),</span> <span class="nb">complex</span><span class="p">)</span>

    <span class="c1"># Account for the timetraces t0</span>
    <span class="n">delays</span> <span class="o">=</span> <span class="n">delays</span> <span class="o">-</span> <span class="n">timetraces_time</span><span class="o">.</span><span class="n">start</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">delays</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">)</span>

    <span class="c1"># Shift transfer func by the frac of the time step</span>
    <span class="n">delays_remainder</span> <span class="o">=</span> <span class="n">delays</span> <span class="o">%</span> <span class="n">dt</span>
    <span class="n">frac_shifted_transfer_func</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">timeshift_spectra</span><span class="p">(</span>
        <span class="n">unshifted_transfer_func</span><span class="p">,</span> <span class="n">delays_remainder</span><span class="p">,</span> <span class="n">toneburst_freq</span>
    <span class="p">)</span>

    <span class="c1"># Calculate timedomain response</span>
    <span class="n">frac_shifted_response</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">rfft_to_hilbert</span><span class="p">(</span>
        <span class="n">frac_shifted_transfer_func</span> <span class="o">*</span> <span class="n">toneburst_f</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">toneburst_time</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Shift timedomain response by a multiple of the time step</span>
    <span class="k">for</span> <span class="n">scat_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numscatterers</span><span class="p">):</span>
        <span class="n">_timeshift_timedomain</span><span class="p">(</span>
            <span class="n">frac_shifted_response</span><span class="p">[</span><span class="n">scat_idx</span><span class="p">],</span>
            <span class="n">delays</span><span class="p">[</span><span class="n">scat_idx</span><span class="p">],</span>
            <span class="n">dt</span><span class="p">,</span>
            <span class="n">toneburst_t0_idx</span><span class="p">,</span>
            <span class="n">timetraces</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">timetraces</span></div>



<div class="viewcode-block" id="transfer_func_to_scanlines">
<a class="viewcode-back" href="../../_autosummary/_autosummary/arim.model/arim.model.transfer_func_to_scanlines.html#arim.model.transfer_func_to_scanlines">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">transfer_func_to_scanlines</span><span class="p">(</span>
    <span class="n">unshifted_transfer_func</span><span class="p">,</span>
    <span class="n">delays</span><span class="p">,</span>
    <span class="n">scanlines_time</span><span class="p">,</span>
    <span class="n">toneburst_time</span><span class="p">,</span>
    <span class="n">toneburst_freq</span><span class="p">,</span>
    <span class="n">toneburst_f</span><span class="p">,</span>
    <span class="n">toneburst_t0_idx</span><span class="p">,</span>
    <span class="n">timetraces</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="ne">DeprecationWarning</span><span class="p">(</span>
            <span class="s2">&quot;transfer_func_to_scanlines is deprecated. Use transfer_func_to_timetraces&quot;</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">transfer_func_to_timetraces</span><span class="p">(</span>
        <span class="n">unshifted_transfer_func</span><span class="p">,</span>
        <span class="n">delays</span><span class="p">,</span>
        <span class="n">scanlines_time</span><span class="p">,</span>
        <span class="n">toneburst_time</span><span class="p">,</span>
        <span class="n">toneburst_freq</span><span class="p">,</span>
        <span class="n">toneburst_f</span><span class="p">,</span>
        <span class="n">toneburst_t0_idx</span><span class="p">,</span>
        <span class="n">timetraces</span><span class="p">,</span>
    <span class="p">)</span></div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2016–2025, arim contributors.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.4.7.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>